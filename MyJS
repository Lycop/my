	/**
	 * 链式回调函数
	 * 1、回调关系链式绑定
	 * 2、调用第一个函数
	 * */
	function chainedFn(chain){
		// 入参数据校验 ...
		for(var i=0;i<chain.length;i++){
			if(!chain[i]["fnName"] || (typeof chain[i]["fnName"]) != "function"){
				console.log("error：参数有误！");
				return;
			}
		}
		
		// 如果只有一条，则直接调用 ...
		if(chain.length < 2){
			(new chain[0]["fnName"](chain[0]["fnArg"])).fnCont();
			return;
		}
		
		// 组合链式函数 ...
		var firstFn = (function combinationFn(index){
			var curFnIndex = index || 0; //当前函数索引
			var curArg = chain[curFnIndex]["fnArg"] || ""; //当前函数参数
			var callBack = ""; //当前函数参数回调
			
			// 如果存在下一条，则将下一条绑定为当前的回调 ...
			if(curFnIndex + 1 <  chain.length){
				callBack  = combinationFn(curFnIndex + 1).fnCont;
			}
			
			var curFn = new chain[curFnIndex]["fnName"](curArg,callBack);	
			if(curFn){
				return curFn;
			}else{
				return false;
			}
			
		})();
		
		// 启动链式回调 ...
		if(typeof firstFn.fnCont == "function"){
			firstFn.fnCont(chain[0]["fnArg"]);
		}
		
	}
